### Spring Boot Optimistic Locking with `@Version`

#### Objective

This exercise aims to provide practical experience with optimistic locking in Spring Boot applications using Spring Data JPA and Hibernate. You will implement an entity with a `@Version` column and demonstrate how concurrent updates to the same entity instance, based on an outdated version, lead to an `OptimisticLockingFailureException`.

#### Instructions

1.  **Project Setup**

    - Create a new Spring Boot project using [start.spring.io](https://start.spring.io/).
    - Include the following dependencies:
      - `Spring Web`
      - `Spring Data JPA`
      - `PostgreSQL Driver`
    - Choose Java 17+ and Maven as your build tool.

2.  **Database Setup**
    - **Install Docker Desktop** if you don't have it already.
    - If you have PostgreSQL on your system already, either stop it, or run the new docker container (see below) on a different port
      - The `-p` flag indicates what port, use `-p 5433:5432` to run it on 5433
    - **Start PostgreSQL Database using Docker:**
      - First, create a Docker named volume to persist your database data. This ensures your data isn't lost if the container is removed:

```bash
docker volume create pgdata
```

        *   Then, run the PostgreSQL container using the `docker run` command. This will create a container named `spring-boot-postgres-db` and expose it on port 5432:

```bash
docker run --name spring-boot-postgres-db \
-e POSTGRES_DB=homework_db \
-e POSTGRES_USER=postgres \
-e POSTGRES_PASSWORD=postgres \
-p 5432:5432 \
-v pgdata:/var/lib/postgresql/data \
--restart always \
-d pgvector/pgvector:0.8.1-pg17-trixie
```

        *   *Explanation:*
            *   `--name spring-boot-postgres-db`: Assigns a readable name to your container.
            *   `-e ...`: Sets environment variables for the PostgreSQL server (database name, user, password).
            *   `-p 5432:5432`: Maps port 5432 on your host machine to port 5432 inside the container.
            *   `-v pgdata:/var/lib/postgresql/data`: Mounts the `pgdata` named volume to the database's data directory, ensuring data persistence.
            *   `--restart always`: Configures the container to start automatically if Docker restarts.
            *   `-d`: Runs the container in detached mode (in the background).
            *   `pgvector/pgvector:0.8.1-pg17-trixie`: Specifies the Docker image to use.
        *   You can verify the container is running by executing `docker ps` in your terminal.
        *   To stop the database container later, use `docker stop spring-boot-postgres-db`. To remove it (and optionally the volume), use `docker rm spring-boot-postgres-db` and `docker volume rm pgdata`.
    *   Configure your `application.properties` (or `application.yml`) file to connect to the new PostgreSQL database.
        *   *Example* `application.properties`:

```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/homework_db
spring.datasource.username=postgres
spring.datasource.password=postgres
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
```

3.  **Entity Definition**
    - Create a simple JPA entity, for example, `Product`, with the following fields:
      - `id` (Long, primary key, generated value)
      - `name` (String)
      - `price` (Double)
      - `version` (Long, annotated with `@Version`)
    - Example `Product` entity structure:

```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private Double price;
    @Version
    private Long version;

    // Constructors, getters, setters
}
```

4.  **Spring Data JPA Repository**

    - Create a Spring Data JPA repository interface for your `Product` entity, extending `JpaRepository`.

5.  **Service Layer**

    - Create a `ProductService` class.
    - The service should be annotated with `@Transactional`.
    - Inject your `ProductRepository` into this service.
    - Add a `createProduct` method that receives a product name and price, uses the product repository to save it, and returns the id of the created product.
    - Also create a `retrieveProduct` method that receives a `Long id` and returns an Optional<Product>
    - Implement a method, e.g., `updateProductPrice(Long productId, double newPrice)`.
      - Inside the method, retrieve the `Product` by its `id`.
      - Update its `price` to `newPrice`.
      - Save the updated `Product` using the repository.

6.  **Demonstrate Optimistic Locking**

    - In your main application class (or a dedicated `ApplicationRunner` component or a test class):
      - **Initialize Data:** Save a new `Product` instance into the database.
    - **Scenario 1: Successful Update:**

      - Fetch the `Product` from the database.
      - Call your `productService.updateProductPrice()` method with a new price.
      - Fetch the product again and observe that the `price` has changed and the `version` has incremented.

    - **Database Verification:** After this successful update, take a moment to verify that the `Product` is correctly saved and updated in your PostgreSQL database. You can do this using a GUI tool like **DBeaver**, **pgAdmin**, or **DataGrip**, or by using the `psql` command-line utility _inside the Docker container_.
      - **Using `psql` (inside Docker):** Open your terminal and execute the following command (ensure your Docker container `spring-boot-postgres-db` is running). This command uses `docker exec` to run the `psql` client directly within the database container.

```bash
docker exec -it spring-boot-postgres-db psql -U postgres -d homework_db
```

        *   *Explanation:*
            *   `docker exec -it spring-boot-postgres-db`: Executes a command interactively (`-it`) inside the running container named `spring-boot-postgres-db`.
            *   `psql -U postgres -d homework_db`: This is the standard `psql` command, but now it runs *inside* the container, connecting to the PostgreSQL server directly within that container. Thus, you don't need to specify `localhost` or the port, as it's a local connection from `psql` to the database server in the same container.
        *   Once connected, execute the following SQL query to see the product (table names are typically lowercased versions of your entity name by default):

```sql
SELECT id, name, price, version FROM product;
```

           *    You should see your product with its updated price and incremented version number. Type `\q` to exit `psql`.

    *   **Scenario 2: Optimistic Locking Failure (Simulated Concurrency):**
        *   We'll use two threads that calling `.updateProductPrice()` at the same time. Be sure to wrap them in a try-catch block as this will create a optimistic locking exception.
        *   Most of the time thread 2 will fail since it is started second, but in theory thread 1 might also fail (depending on the OS scheduler)
        *   Example code:

```Java
// Simulate two concurrent updates
Thread thread1 = new Thread(() -> {
    try {
        productService.updateProductPrice(productId, 130.0);
    } catch (ObjectOptimisticLockingFailureException e) {
        System.out.println("Optimistic locking failure in thread 1!");
    }
});

Thread thread2 = new Thread(() -> {
    try {
        productService.updateProductPrice(productId, 140.0);
    } catch (ObjectOptimisticLockingFailureException e) {
        System.out.println("Optimistic locking failure in thread 2!");
    }
});

thread1.start();
thread2.start();
thread1.join();
thread2.join();
```

    *   Make a **screenshot** of successfully having run your application (and getting the optimistic locking failure), to be submitted as the next deliverable.

7.  **README.md**
    - Create a `README.md` file at the root of your project.
    - Describe how to run your application.
    - Clearly explain the output you expect to see, particularly how the optimistic locking failure is demonstrated in the console output.

#### Submission

Delete the target directory from your project, or run `mvn clean`. Then zip your entire Spring Boot project directory (including the `src` folder, `pom.xml`, and your `README.md`) and submit the `.zip` file.

#### Grading Criteria

This exercise will be graded out of 10 points based on the following:

- **2 points:** Correct Spring Boot project setup with necessary dependencies.
- **2 points:** Correct definition of the `Product` entity, including the `@Version` annotation.
- **2 points:** Proper implementation of `ProductRepository` and `ProductService` with a transactional update method.
- **3 points:** Successful demonstration of optimistic locking, including:
  - Initial product creation and a successful update (with confirmation in the database).
  - Correct simulation of concurrent updates leading to an `OptimisticLockingFailureException`.
  - Screenshot of the application running and getting the exception.
- **1 point:** Clear and concise `README.md` file explaining how to run the application and interpret the output, especially the optimistic locking failure demonstration.

**Total: 10 points**
